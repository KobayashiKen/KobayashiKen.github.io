<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java源码 —— Object]]></title>
    <url>%2F2018%2F11%2F23%2Fjava%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20Object%2F</url>
    <content type="text"><![CDATA[写在最前面，阅读代码能力比较差，借此机会先好好阅读一遍必要的java源码，共勉 java.lang.ObjectJava所有类的父类，在你编写一个类的时候，若无指定父类（没有显式extends一个父类）一般编译器会添加Object为该类的父类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Class &#123;@code Object&#125; is the root of the class hierarchy. * Every class has &#123;@code Object&#125; as a superclass. All objects, * including arrays, implement the methods of this class. * * @author unascribed * @see java.lang.Class * @since JDK1.0 */public class Object &#123; //本地方法，C/C++在DLL中实现，通过JNI(Java Native Interface)调用 //关于Native的可以参考文章末尾的链接了解 private static native void registerNatives(); //static代码块随着类的加载，只加载一次。调用此方法 static &#123; registerNatives(); &#125; //返回此Object的运行时类（每个类的Class类对象） public final native Class&lt;?&gt; getClass(); //有native，说明有调用系统底层，返回一个和内存地址有关的hash值 public native int hashCode(); //默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法 //主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象），即等同于“==” public boolean equals(Object obj) &#123; return (this == obj); &#125; //本地clone方法 protected native Object clone() throws CloneNotSupportedException; //返回对象的的字符串表示，默认是：类名+@+16进制的hash值 public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; //线程同步相关方法 public final native void notify(); //线程同步相关方法 public final native void notifyAll(); //线程同步相关方法 public final native void wait(long timeout) throws InterruptedException; //线程同步相关方法 public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; //线程同步相关方法 public final void wait() throws InterruptedException &#123; wait(0); &#125; //对象被回收时调用，一个对象只调用一次 protected void finalize() throws Throwable &#123; &#125;&#125; &emsp;Java:基础认识&amp;理解关键字native registerNatives()有native修饰符，该方法是JNI环境提供的用于注册Native方法的方法 getClassgetClass()也是一个native方法，返回的是此Object对象的类对象或运行时类对象Class&lt;?&gt;也就是说12345678910class Animal&#123;&#125;class Dog extends Animal&#123;&#125;class SingleDog extends Dog&#123;&#125;Animal a = new SingleDog();Dog d = (Dog)a;SingleDog s = (SingleDog)d;这三个对象的getClass().getName()均为SingleDog，因为=前面的是静态类型，这个引用类型会根据需要向上或者向下转型，而在运行期间不变的就是=后面的动态类型 hashCodehashCode 的常规协定是： 在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。 如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 equals没重写过的equals方法和==的作用一样，通过两个对象的内存地址判断是否为同一个对象，虽说没有强制需要同时重写equals()方法和hashCode()方法，但是这是一个约定俗成的规则，重写equals的同时也要重写hashCode()按照jdk的技术规范里的总结一下 若hash值不相等，则两个对象肯定不等（不equals） 若hash值相等，两个对象不一定相等（不一定equals） equals相等，hash值必须相等 clone克隆几乎没用过，没什么实在感，有一个博主讲的比较详细java.lang.Object总结 notify() ,notifyAll(),wait() notify：随机唤醒等待（wait）队列中一个对象，使其需要该对象的线程继续执行； notifyAll：唤醒队列中所有对象 wait：该对象陷入等待状态，需要该对象的线程将不能再继续执行，直到该对象由其他线程调用notify/notifyAll方法唤醒。 finalize一个奇怪的方法，是jvm回收垃圾前需要执行的操作，建议不用或者少且简单的用，有jvm管理内存的话，这些活都交给jvm就行了]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java源码</tag>
      </tags>
  </entry>
</search>
